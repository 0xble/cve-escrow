// SPDX-License-Identifier: MIT
pragma solidity 0.8.13;

import { ERC4626, ERC20, SafeTransferLib, FixedPointMathLib } from "./mixins/ERC4626.sol";
import { ERC20MultiVotes } from "./tokens/ERC20MultiVotes.sol";
import { ERC20Gauges } from "./tokens/ERC20Gauges.sol";
import { Auth, Authority } from "solmate/auth/Auth.sol";

// TODO:
// - [x] Add functionality to only allow transferring of locks with a certain unlock time.
// - [ ] Add functionality to process expired locks.
// - [ ] Consider rewards model that allows claiming rewards without redeeming veCVE.

interface CVE {
    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);

    function getCurrentVotes(address account) external view returns (uint96);
}

/**
 * @title Vote-Escrowed Curvance Token
 * @notice Curvance's ERC4626-compatible, yield-bearing, reward-distributing, gauge-enabled, and vote-escrow token.
 * @author Brian Le
 */
contract CveEscrow is ERC20MultiVotes, ERC20Gauges, ERC4626 {
    using SafeTransferLib for ERC20;
    using FixedPointMathLib for uint256;

    // =========================================== LOCK TIME CONFIG ===========================================

    /**
     * @notice The next timestamp that the next batch of locks will unlock.
     * @dev Locks have a "synchronized" unlock time. This is done so they can be fungible and
     *      usable for trading pairs. Locks are unlocked at the same time on a yearly basis.
     */
    uint64 public nextUnlockTime;

    /**
     * @notice Maximum duration over which batches of CVE are locked for at a time.
     */
    uint32 public constant lockDuration = 365 days;

    /**
     * @notice Check if the next unlock time needs to be updated.
     * @dev This check is run before any core functionality is performed.
     */
    modifier checkUnlockTime() {
        if (block.timestamp >= nextUnlockTime) nextUnlockTime += lockDuration;

        _;
    }

    // ========================================== USER LOCKS STORAGE ==========================================

    /**
     * @notice Data stored for each lock.
     * @param shares amount of shares left in this lock
     * @param unlockTime timestamp which shares will unlock and can be redeemed for underlying CVE
     */
    struct Lock {
        uint192 shares;
        uint64 unlockTime;
    }

    /**
     * @notice Get all the locks owned by an address.
     */
    mapping(address => Lock[]) public getLocks;

    /**
     * @notice Get the current index of the last non-zero lock for an address.
     * @dev Saves gas during looping over potentially many locks.
     */
    mapping(address => uint256) public currentLockIndex;

    // ============================================ REWARDS CONFIG ============================================

    /**
     * @notice List of extra rewards to be distributed to vote-escrow holders upon redemption.
     */
    ERC20[] public rewardTokens;

    /**
     * @notice Gets the list of reward tokens.
     * @dev This is provided because Solidity converts public arrays into index getters,
     *      but we want a way to allow external contracts and users to access the whole array
     *      in a single call.
     */
    function getRewardTokens() external view returns (ERC20[] memory) {
        return rewardTokens;
    }

    /**
     * @notice Adds a reward to the list of reward tokens.
     * @param reward address of the reward to add
     */
    function addRewardToken(ERC20 reward) external requiresAuth {
        rewardTokens.push(reward);
    }

    /**
     * @notice Changes the list of reward tokens.
     * @param newRewardTokens list of addresses of new reward tokens to distribute
     */
    function setRewardTokens(ERC20[] calldata newRewardTokens) external requiresAuth {
        rewardTokens = newRewardTokens;
    }

    // ============================================= CONSTRUCTOR =============================================

    constructor(
        ERC20 _cve,
        uint32 _gaugeCycleLength,
        uint32 _freezeDuration,
        address _teamMultisig,
        Authority _authority
    )
        Auth(_teamMultisig, _authority)
        ERC20Gauges(_gaugeCycleLength, _freezeDuration)
        ERC4626(_cve, "Vote-Escrowed Curvance Token", "veCVE")
    {
        // Initialize the next unlock time to a year from time of deployment.
        nextUnlockTime = uint64(block.timestamp + lockDuration);
    }

    // ============================================= CORE LOGIC =============================================

    function beforeDeposit(
        uint256,
        uint256,
        address
    ) internal override checkUnlockTime {}

    function afterDeposit(
        uint256,
        uint256 shares,
        address receiver
    ) internal override {
        Lock[] storage userLocks = getLocks[receiver];
        Lock storage lastLock = userLocks[userLocks.length - 1];

        if (block.timestamp > lastLock.unlockTime) {
            userLocks.push(Lock({ shares: uint192(shares), unlockTime: nextUnlockTime }));
        } else {
            lastLock.shares += uint192(shares);
        }
    }

    function beforeWithdraw(
        uint256,
        uint256 shares,
        address,
        address owner
    ) internal override checkUnlockTime {
        Lock[] storage locks = getLocks[owner];

        uint192 leftToRedeem = uint192(shares);

        for (uint256 i = currentLockIndex[owner]; ; i++) {
            Lock storage lock = locks[i];

            uint192 newLockShares;

            // Only redeem shares that have unlocked.
            if (block.timestamp >= lock.unlockTime) {
                uint192 lockShares = lock.shares;
                uint192 redeemedShares = leftToRedeem > lockShares ? lockShares : leftToRedeem;
                newLockShares = lock.shares - redeemedShares;

                leftToRedeem -= redeemedShares;

                lock.shares = newLockShares;
            }

            if (leftToRedeem == 0) {
                // Store the index of the last non-zero lock to save gas on future looping.
                currentLockIndex[owner] = newLockShares != 0 ? i : i + 1;
                break;
            }
        }
    }

    function afterWithdraw(
        uint256,
        uint256 shares,
        address receiver,
        address
    ) internal override {
        for (uint256 i; i < rewardTokens.length; i++) {
            ERC20 reward = rewardTokens[i];

            uint256 rewards = convertToRewards(reward, shares);

            // Transfer any extra rewards for shares redeemed.
            if (rewards > 0) reward.safeTransfer(receiver, rewards);
        }
    }

    // =========================================== ACCOUNTING LOGIC ===========================================

    /**
     * @notice Total amount of CVE in the escrow.
     */
    function totalAssets() public view override returns (uint256) {
        return asset.balanceOf(address(this));
    }

    /**
     * @notice Total locked balance of an account.
     * @param owner address to find balance of
     */
    function lockedBalanceOf(address owner) external view returns (uint256 shares) {
        Lock[] memory locks = getLocks[owner];

        for (uint256 i; i < locks.length; i++) {
            Lock memory lock = locks[i];

            if (block.timestamp >= lock.unlockTime) break;

            shares += lock.shares;
        }
    }

    /**
     * @notice The amount of a reward exchanged for the amount of shares redeemed.
     * @param reward address of the reward token
     * @param shares amount of shares to redeem
     * @return rewards amount of rewards exchangable for the shares
     */
    function convertToRewards(ERC20 reward, uint256 shares) public view returns (uint256) {
        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.

        return supply == 0 ? shares : shares.mulDivDown(reward.balanceOf(address(this)), supply);
    }

    // =========================================== VOTING LOGIC ===========================================

    /**
     * @notice Get voting power of veCVE and underlying CVE voting power for user.
     * @param account address to calculate voting power of
     */
    function getVotes(address account) public view override returns (uint256) {
        return super.getVotes(account) + convertToShares(CVE(address(asset)).getCurrentVotes(account));
    }

    /**
     * @notice Get past voting power at a given block of veCVE and underlying CVE voting power for user.
     * @param account address to calculate voting power of
     * @param blockNumber block number in the past to get voting power from
     */
    function getPastVotes(address account, uint256 blockNumber) public view override returns (uint256) {
        return
            super.getPastVotes(account, blockNumber) +
            convertToShares(CVE(address(asset)).getPriorVotes(account, blockNumber));
    }

    /**
     * @notice Trigger to manually emit events for voting balances.
     * @dev This is important because this contract cannot be synchronously notified of CVE delegations.
     */
    function emitVotingBalances(address[] calldata accounts) external requiresAuth {
        for (uint256 i = 0; i < accounts.length; i++) emit DelegateVotesChanged(accounts[i], 0, getVotes(accounts[i]));
    }

    // =========================================== ERC20 LOGIC ===========================================

    function beforeTransfer(
        address from,
        address to,
        uint256 amount,
        uint256 unlockTime
    ) internal {
        Lock[] storage fromUserLocks = getLocks[from];
        Lock[] storage toUserLocks = getLocks[to];

        uint192 leftToTransfer = uint192(amount);
        bool filterLocksByUnlockTime = unlockTime != 0;

        for (uint256 i = currentLockIndex[from]; ; i++) {
            Lock storage fromLock = fromUserLocks[i];

            uint64 fromLockUnlockTime = fromLock.unlockTime;

            // Only transfer shares with a certain unlock time if specified.
            if (filterLocksByUnlockTime && fromLockUnlockTime != unlockTime) continue;

            uint192 lockShares = fromLock.shares;
            uint192 transferredShares = leftToTransfer > lockShares ? lockShares : leftToTransfer;
            uint192 newFromLockShares = fromLock.shares - transferredShares;

            leftToTransfer -= transferredShares;

            fromLock.shares = newFromLockShares;

            Lock storage lastLock = toUserLocks[toUserLocks.length - 1];

            // Transfer shares to the end of receiver's list of locks.
            if (fromLockUnlockTime > lastLock.unlockTime || lastLock.shares == 0) {
                toUserLocks.push(Lock({ shares: transferredShares, unlockTime: fromLockUnlockTime }));
            } else {
                lastLock.shares += transferredShares;
            }

            if (leftToTransfer == 0) {
                currentLockIndex[owner] = newFromLockShares != 0 ? i : i + 1;
                break;
            }
        }
    }

    /**
     * @notice Transfer veCVE to another address.
     * @param to address to address to
     * @param amount amount of veCVE to transfer
     * @param unlockTime only transfer shares with this unlock time, specify 0 to ignore
     * @return bool whether the transfer was successful
     */
    function transfer(
        address to,
        uint256 amount,
        uint256 unlockTime
    ) public returns (bool) {
        beforeTransfer(msg.sender, to, amount, unlockTime);

        _decrementWeightUntilFree(msg.sender, amount);
        _decrementVotesUntilFree(msg.sender, amount);

        return ERC20.transfer(to, amount);
    }

    /**
     * @notice Transfer veCVE from an address to another address.
     * @param from address to address from
     * @param to address to address to
     * @param amount amount of veCVE to transfer
     * @param unlockTime only transfer shares with this unlock time, specify 0 to ignore
     * @return bool whether the transfer was successful
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount,
        uint256 unlockTime
    ) public returns (bool) {
        beforeTransfer(from, to, amount, unlockTime);

        _decrementWeightUntilFree(msg.sender, amount);
        _decrementVotesUntilFree(msg.sender, amount);

        return ERC20.transferFrom(from, to, amount);
    }

    function transfer(address to, uint256 amount) public override(ERC20, ERC20Gauges, ERC20MultiVotes) returns (bool) {
        return transfer(to, amount, 0);
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public override(ERC20, ERC20Gauges, ERC20MultiVotes) returns (bool) {
        return transferFrom(from, to, amount, 0);
    }

    function _burn(address from, uint256 amount) internal override(ERC20, ERC20Gauges, ERC20MultiVotes) {
        ERC20Gauges._burn(from, amount);
    }
}
